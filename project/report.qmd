---
title: "GPGN 598A: Final Project"
subtitle: "Specster: a specfem/FWI harness"
bibliography: references.bib
date: 2023-04-29
author:
  - name: Derrick Chambers
    url: https://derchambers.com
    affiliation: Colorado School of Mines
    affiliation-url: https://mines.edu

format:
  pdf:
    # toc: true
    # toc-depth: 1
    number-sections: true
    colorlinks: true
header-includes:
 \usepackage{wrapfig}
 \usepackage{float}
 \floatplacement{figure}{H}
 \usepackage{amsmath}
---

# Introduction

This report is submitted in fulfillment of the term project for GPGN 598A: Full Waveform Inversion (FWI) taken at the Colorado School of Mines in spring of 2023. The assignment was to conduct a full waveform inversion in two dimensions. In order to learn the important implementation details of FWI workflows and the intricacies of SPECFEM2D, the wavefield solver, I opted to create a python package for conducting this project rather than using existing workflow solutions, such as [seisflows](https://github.com/adjtomo/seisflows). The python implementation is called [specster](https://github.com/d-chambers/specster) and it consists of nearly 2000 lines of python implementation code and 500 lines of test code (with several hundred tests in total). This report will highlight the use of the specster library in order to interact with SPECFEM2D and conduct a few iterations of FWI. 

# Installation

Currently, specster can be installed from git using pip (provided
git is installed)

```bash
pip install git+https://github.com/d-chambers/specster
```

Next, you must set your environment variable "SPECFEM_BIN_PATH" and "SPECFEM2D_PATH" so specster can find specfem binaries and example directories respectively.


# Specfem interactions

Specster interacts specfem 2D through a control class known as `Control2d`. `Control2d` provides several useful features to:

- Plot simulation geometries
- Run meshing and simulations
- Parse receivers and sources into tables
- Changes simulation parameters

Examples of these are presented in the following sections:

## Control2D initialization 

There are three ways to initialize `Control2D` objects: 

```python
import specster as sp

# loads the base example then copies files to temporary directory
control_default = sp.Control2d().copy()
# loads an example included in the specfem2D directory by name
# and copies contents to a new path
control_example = sp.load_2d_example("Tape2007")
# or from your own directory which at least includes a DATA directory 
# and parfile.
control = sp.Control2d("path/to/your/file")
```

## Plotting simulation geometry

Visualizing the station/source geometry and background models is useful to quickly understand the simulation. In specster this is easy:

```python
import specster as sp

# loads the base example then copies files to temporary directory
# this is needed because the mesher may need to be run to generate models.
control = sp.Control2d().copy()
control.plot_geometry(kernel=['vs', 'vp'])  # plots VP and VS
```

Sources are shown as red stars, receivers as triangles, and grid quantities (in this case P/S wave speed) are plotted in separated panels as in @fig-basic_geometry. 

![Basic geometry plot of default example](outputs/a010_basic_plot.png){#fig-basic_geometry}

## Running a forward simulation and output inspection

Forward simulations are are conducted with the `Control2d.run` method. You will see the specfem2d piped to the terminal or notebook upon calling this method. 

`Control2d.run` is able to figure out which programs to run based on values in the par file. For example, if the par file specifies an external mesh is to be used, it will not run the meshing program.   

```python
import shutil
from pathlib import Path

import specster as sp

path = Path("outputs/run_example")

if path.is_dir():
    shutil.rmtree(path)

# prepare control for forward simulation
control = (
    sp.Control2d()
    .copy(path)  # make copy to path
    .prepare_fwi_forward()  # set params to forward mode
)

output = control.run()
```
The resulting object
Now we can get the resulting waveforms as an [obspy.Stream](https://docs.obspy.org/packages/autogen/obspy.core.stream.Stream.html) object (@fig-stream_plot).

```python
st = output.get_waveforms()  # get obspy streams
st.select(component='Z')[:3].plot()  # plot first 3 streams
```


![Plot of output streams](outputs/a030_stream_plot.png){#fig-stream_plot fig-height=.5%}


We can also get important result parameters from the output object that let us know the health of the simulation.


```python
stats = output.stats  # get obspy streams
stats.elements  # number of elements
stats.max_frequency_resolved  # the maximum freq form the source
stats.min_gll_distance  # min spacing of GLL points
stats.max_cfl  # max clf ratio. Should be less than 0.5 or so.
```

We can also get a histogram of the number of GLL points per the shortest wavelengths for the different regions in the model (@fig-gll_hists)

```python
output.plot_gll_per_wavelength_histogram()
```

![GLL per wavelength histograms](outputs/a030_gll_hist.png){#fig-gll_hists}


# Modifying stations and sources

Stations and sources can be modified directly through the `station` and `sources` parameter. Here are a few examples:

Make a copy, remove all but one station, add another source, and plot geometry (@fig-modified_geometry). 

```python
control = control.copy()

control.stations = control.stations[:1]

new_source = control.sources[0].copy()
new_source.xs, new_source.zs = 1500, 1500
control.sources.append(new_source)

control.write(overwrite=True)

control.plot_geometry(kernel=['vs', 'vp'])
```

![Modified geometry](outputs/a040_modified_geometry.png){#fig-modified_geometry}


Now plot the geo

Add an extra source





# Low level modifications

For many use cases, users shouldn't have to modify the parameters contained in the specfem par_file directory. However, then these do need to be modified, this is done through the `par` attribute of `Control2d`. `par` is a hierarchy of [pydantic models](https://docs.pydantic.dev/latest/usage/models/) which matches the structure of the par file. They also validate inputs to help prevent producing an invalid par_file. For example:

```python
# dt must be a float so this doesn't work
control.par.dt = "bob"
# but strings that can be converted to floats do work
control.par.dt = "0.1"
```

Switch from P/SV mode to SH:

```python
control.par.p_sv = False
```

Configure control to not output postscript files; they are too big!

```python
control.par.visualizations.postscript.output_postscript_snapshot = False
```

Once all changes have been made, we need to write the control state back to disk using the `Control2d.write` method.

```python
# overwrite is true to replace existing par file.
control.write(overwrite=True)
```
 
Of course, you can just modify the par_file directly in a text editor then 
create a new `Control2d` object to update the state. 


# Full Waveform Inversion

Specster provides a few different abstraction levels for performing full waveform inversion. Using `Control2d` directly would be the lowest level of abstraction, but it will be informative to see how this is done before moving to higher abstraction levels. 

## Single event-station kernel calculation

The following shows how to calculate and visualize a single event kernel and a single station with Specster. 

The first step is to create the base geometry. We will simply use a homogeneous model  so this document is completely reproducible without any external files and the results are easily interpretable. 

First, setup the control structure and run forward for our "true" model. 

```python
import specster as sp

control_true = sp.load_2d_example('homogeneous_2d').copy("outputs/kernel_one_one_true")

control_true.stations = control_true.stations[:1]
control_true.prepare_fwi_forward()
control_true.run()
```

![](outputs/a050_single_single_geometry.png)

Next, we setup our initial model by modifying the velocity. 

```python
control_initial = control_true.copy("outputs/kernel_one_one_true")

control_initial.par.material_models.models[0].vs *= 0.98
control_initial.prepare_fwi_forward()
control_initial.run()
```

Next, use the misfit classes form the FWI module to calculate the misfit and adjoint sources. We will simply use the waveform misfit but travel time and amplitude misfit functions are also implemented. Then we run the initial control in fwi_adjoint mode. 


```python
from specster.fwi.misfit import WaveformMisFit

# load seismograms as Streams
st_true = control_true.output.get_waveforms()
st_initial = control_initial.output.get_waveforms()

# calculate adjoint source
misfitter = WaveformMisFit(st_true, st_initial)
adjoint_source = misfitter.get_adjoint_sources()
adjoint_source.plot()

# write adjoints to initial and run
control_initial.write_adjoint_sources(adjoint_source)
control_initial.prepare_fwi_adjoint()
control_initial.run()
```

![Adjoint source example](outputs/a050_adjoint_plot.png){#fig-simple_adjoint}

Finally, we load the kernel and plot.


```python
output = control_initial.output

kernel = load_event_kernel()
output
from specster.fwi.misfit import WaveformMisFit

# load seismograms as Streams
st_true = control_true.output.get_waveforms()
st_initial = control_initial.output.get_waveforms()

# calculate adjoint source
misfitter = WaveformMisFit(st_true, st_initial)
adjoint_source = misfitter.get_adjoint_sources()

# write adjoints to initial and run
control_initial.write_adjoint_sources(adjoint_source)
control_initial.prepare_fwi_adjoint()
control_initial.run()
```

Now we can plot the banana donut.

```python
output = control_initial.output
output.plot_kernel(kernel='beta')
```

![](outputs/a050_sing_single_donut.png)

This exercise could, of course, be repeated for multiple stations, but the workflow is identical. Things get more interesting in more realistic cases involving multiple stations and multiple events. 

## Multiple Events and Multiple Stations

First, I will demonstrate a multi-event multi-station workflow. One simple case is to use a nearly homogeneous velocity model with a small inclusion in the center and very good coverage of events and stations. Specster's "inclusion_2d" dataset was created for this purpose.


```python
import specster as sp

control_true = sp.load_2d_example("inclusion_2d").copy("out/inclusion_2d_path")
control_true.plot_geometry(kernel='vs')
```

![](outputs/a060_inclusion_geometry.png)


Next, we need to split each source into a separate run (because I am not attempting source encoding). Fortunately, all of these runs are done in parallel using python's multiprocessing functionality. In the future it could be simplified even more to just make asynchronous command line calls.

```python
control_true.run_each_source()
```

This will create a directory called "EACH_SOURCE" and populate it with copies of the specfem DATA directories although each has been modified to only include one source. The source directories are simply numbered sequentially starting with "000000".

These will represent our "True" waveforms. Of course, we also need an initial model and data. For this, we will start with a homogenous background model.
```python
import specster as sp

control_initial = control_true.copy("out/inclusion_2d_initial")

# modify the second material property to match first. Homogenizes the model. 
models = control_initial.par.material_models.models
models[1].Vs = models[0].Vs
models[1].Vp = models[0].Vp
models[1].rho = models[0].rho

control_initial.write(overwrite=True)
fig, *_ = control_initial.plot_geometry(kernel='vs')

```

![](outputs/a062_inclusion_geometry.png)



It will then get tedious to work with multiple `Control2d` objects for each event, but Specster provides a higher level control class for facilitating the FWI workflow.

```python
import specster as sp
from specster.fwi.misfit import WaveformMisFit

inverter = sp.Inverter(
    # Specifies where true data are found
    observed_data_path=control_true.each_source_path,
    # The initial control is used to setup the inversion
    control=control_initial,
    # A "true" control object is needed to compare model misfit
    true_control=control_true,  
    # The working_path optionally specifies where the inverter does its work
    working_path="outputs/fwi_inclusion_2d",
    # specifies the misfit function.
    misfit=WaveformMisFit,
)
```







# References
