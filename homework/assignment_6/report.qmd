---
title: "GPGN 598A: Assignment #6"
subtitle: Ray Tomography
bibliography: references.bib
date: 2023-04-07
author:
  - name: Derrick Chambers
    url: https://derchambers.com
    affiliation: Colorado School of Mines
    affiliation-url: https://mines.edu

format:
  pdf:
    # toc: true
    # toc-depth: 1
    number-sections: true
    colorlinks: true
header-includes:
 \usepackage{wrapfig}
 \usepackage{float}
 \floatplacement{figure}{H}
 \usepackage{amsmath}
---

# Abstract

The purpose of this assignment is to explore ray-based tomography techniques
for estimating earth structure.

# Forward Problem

## Model Parameterization

For this assignment, perturbations of the current earth model 
are described in terms of $M$ basis functions:

$$
\delta ln(c(x)) = \sum_{k=1}^{M} \delta m_k B_k (x)
$${#eq-peturb}

In this case, the basis functions selected ($B_k$) are the spherical splines of 
@wang1995spherical. 

::: {.callout-note appearance="simple"}

## Question 1a

What is the value of the q = 8 spline function that is centered at (longitude, latitude)
= ($−117^{\circ}$ , $34^{\circ}$ ), evaluated at the point ($−117.05^{\circ}$ , $34.25^{\circ}$ )?

:::

```{python}
from raytape import spline_vals

out = spline_vals(
    clon=-117,
    clat=34,
    scale=8,
    lon_vec=[-117.05],
    lat_vec=[34.25],
    cols=1,
)
print(out[0][0])
```


::: {.callout-note appearance="simple"}

## Question 1b

Formulate an entry of the design matrix. From the class notes, the ray theory travel-
time perturbation for the ith source-receiver combination is given by

$$
\delta T_i = - \int_{ray_i} c^{-1} \delta ln(c) ds,
$${#eq-dT}

where ds denotes a segment of the ith ray. Show how this leads to $d = G \delta m$, 
where the data vector is given by

$$
d = (\delta T_{1} , . . . , \delta T_{i} , . . . , \delta T_{N} )^{T},
$${#eq-d}

and write the expression for the $G_{ik}$ element of the design matrix $G$.
:::

To derive an expression for $G_{ik}$ we can work backwards by substituting 
@eq-peturb into @eq-d. 

$$
\delta T_{i} = \int_{ray_i} c^{-1} \sum_{k=1}^{M} \delta m_k B_k (x) ds
$$

And since the summation term can be rewritten in terms of a dot product
(using Einstein's summation notation)

$$
\delta T_{i} = \int_{ray_i} c^{-1} B_k  ds  \cdot \delta m_k  
$$

Hence,

$$
G_{ik} = \int_{ray_i} c^{-1} B_k  ds
$${#eq-gik}

and thus it follows:

$$
d = G \delta m
$$

::: {.callout-note appearance="simple"}

## Question 1c

What is the value of G ik with i = 126 and k = 204? What does each row of G
correspond to? What does each column of G correspond to?

:::


```{python}
import numpy as np

ar = np.load("outputs/G.npy")
print(ar[126, 204])
print(ar[125, 203])
```

Each row of G corresponds to a particular ray and each column corresponds to the value
of a spline basis function.

:::{callout-note}
Because python indexing starts at 0, and Matlab's starts at 1, I have printed both
the G value for the requested index and the previous index (which will match the
Matlab answer.) 
:::

To double check the values in the G matrix, I created several plots of random ray paths
showing a straight-line from source to receiver and the values of the effected spline
functions. @fig-ray-path shows one such example. After plotting approximately 100
ray paths, I am convinced the G matrix contains reasonable values because the splines
nearest the ray path have the highest values with smoothly varying values away from
the ray path.

![Example Ray Path and G values.](outputs/ray_plots/example.png){#fig-ray-path}


:::{.callout-note appearance="simple"}

# Question 2a

Write the symbolic expression for the solution δm to the least squares problem Gδm =
d in the case where GT G is full rank. List the dimensions of δm, d, G, GT G, and
GT d

:::

Assuming G is full rank and thus doesn't require damping/conditioning:

$$
G \delta m = d
$$

$$
G^T G \delta m = G^T d
$$

$$
\delta m = (G^T G)^{-1} G^T d
$${#eq-delta_m}

The dimensions of the requested symbols are as follows:

| Symbol     | Dimensions | 
|------------|------------|
| $\delta$ m | k x 1      |
| $d$        | i x 1      |
| $G$        | i x k      |
| $G^T G$    | k x k      |
| $G^T d$    | k x 1      |

:::{.callout-note}
The provided $d$ array is the difference between the observed travel times
and the predicted. Otherwise, we would need to calculate this value from 
travel times, phase picks, and event origin times.
:::

:::{.callout-note appearance="simple"}

# Question 2c

Compute δm using the formula above. What do you get, and why is this the case?
:::

The above operation isn't possible; the inverse function
raises an error stating that the matrix $G^T G$ is a singular.


:::{.callout-note appearance="simple"}

# Question 2d

Compute δm for a range of λ values: for example, try
lamvec = 10.^linspace( log10(minlam), log10(maxlam), numlam);
with λ min = 0.1 and λ max = 40.0.

:::

The following plots show the requested $\delta m$ values for various values
of $lambda$:

```{python}
#| echo: false
from pathlib import Path
import matplotlib.pyplot as plt

dir_path = Path("outputs/a050_velocity_change_plots")



# Plot PNG files
for png_file in sorted(dir_path.glob("*.png")):
    img = plt.imread(png_file)
    plt.imshow(img)
    plt.gca().axis('off')
    plt.show()
```

As the values of $\lambda$ increase, the results appeared more "smoothed" and the high 
amplitude anomalies around the boarder of the checkerboard begin to vanish. Clearly, 
some $\lambda$ is required but it would be somewhat subjective to determine the right
value of the initial model perturbations weren't as obvious.

Using the same parameters as before, the inversion was run again but this time only
including 5 events. The results are similar to those produced by using all of the events
but lack some resolution. 


```{python}
#| echo: false
from pathlib import Path
import matplotlib.pyplot as plt

dir_path = Path("outputs/a070_velocity_change_reduced_plots")



# Plot PNG files
for png_file in sorted(dir_path.glob("*.png")):
    img = plt.imread(png_file)
    plt.imshow(img)
    plt.gca().axis('off')
    plt.show()
```


:::{.callout-note appearance="simple"}

# Question 2g

What are two ways to stabilize the inverse problem, given total control over the 
experimental design?

:::

The inverse problem can be stabilized by either 1) increasing the ray path coverage,
e.g., by adding more stations and sources in areas that have little coverage, or two,
better conditioning for the design matrix. The latter point can be achieved with a
singular value decomposition.

# References